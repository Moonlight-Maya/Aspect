//Keep a lowercased table, since we don't want keywords
//to be case sensitive
lowercasedPartsTable = $[]

//Find the vanilla model part which matches the given name, if it exists, or else null
fn findPart(name) {
	found = null
	//Set found to null, iterate the parts table to find the correct vanilla part
	lowercasedPartsTable.each(fn(partName, part) {
		if found or partName.class() == 0.class() //already found, or it's a number, skip
			return null
		if name.starts(partName)
			found = part
	})
	//return the found part, or null if we found nothing
	found
}

fn setupKeywordsRecursive(modelPart) {
	//Only set keywords for groups
	if modelPart.bbType() == "GROUP" {
		//If we find a part, then add it to the transformers list
		if (vanillaPart = findPart(modelPart.name()))
			modelPart.transformers().push(vanillaPart)
		
		//Recurse on all the children
		modelPart.getChildren().each(this)
	}
}

//Run this function and your part names will be scanned for keywords,
//and the vanilla parents will be added accordingly
global fn setupKeywords() {
	//Vanilla model only exists once the user is loaded in,
	//so register this to the event
	events.USER_INIT.add(fn() {
		//Generate a copy of the vanilla parts with lowercase names,
		//just in case any names aren't already lowercase
		lowercasedPartsTable.clear()
		vanilla.parts().each(fn(partName, part) {
			//If the part name is a string, lowercase it, if it's a number, don't
			lowercasedPartsTable[
				if partName.class() == "".class() partName.lower() else partName
			] = part
		})

		//Recursively setup keywords for parts
		setupKeywordsRecursive(models.entity)
		setupKeywordsRecursive(models.hud)
		models.world.eachV(setupKeywordsRecursive)

		//Remove this after it's called
		events.USER_INIT.remove(this)
	})
}
