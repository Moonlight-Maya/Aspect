
//Store and update this in a global variable so that it can be
//read by __tostring functions if desired
global PPRINT_DEPTH = 0
global PPRINT_MAX_DEPTH = 0

tableClass = $[].class()
listClass = ![].class()
stringClass = "".class()

global PPRINT_SPACER_COLOR = "#AAAAAA"
global PPRINT_SPACES = 2
global PPRINT_COLOR_NULL = "#FF3333"
global PPRINT_COLOR_RECURSION = "#00F0FF"
global PPRINT_COLOR_TABLE = $[
	[tableClass] = "#FF5555",
	[listClass] = "#AA55FF",
	[stringClass] = "#FFFF55",
	[true.class()] = "#55FFFF",
	[0.class()] = "#55FF55"
]

fn colorOf(object) {
	if object == null 
		PPRINT_COLOR_NULL 
	else
		PPRINT_COLOR_TABLE[object.class()]
}

//Append to the json, print the object without recursing
fn printEndpoint(json, object, isKey, allowHover) {
	//If it's not a key and is a string, surround with quotes
	q = if not isKey and object.class() == stringClass "\\\"" else ""
	json.next(q + str(object) + q)
	if (not isKey and (c = colorOf(object)))
		json.color(c)

	//Hover text, if needed
	if allowHover and (object.class() == tableClass or object.class() == listClass) {
		//No hovers within hovers, infinite stack overflow
		hoverText = pformat(object, 1, false) 
		json.hover(hoverText)
	}
}

//Append to the json
fn printRecursive(json, object, depthLeft, indent, allowHover, alreadyPrinted) {

	//No depth left, just print the endpoint and quit
	if depthLeft == 0 {
		printEndpoint(json, object, false, allowHover)
		return null
	}

	//Create spacing string
	spacerPart = "|" + " " * (PPRINT_SPACES - 1)
	spacing = spacerPart * indent

	//If this object is a table or list, but we already printed it, then instead print it without recurse
	if alreadyPrinted[object] {
		hoverText = JsonText("Duplicate of earlier object:\n").color("gold").concat(pformat(object, 1, false))
		json.next("[RECURSION]").hover(hoverText).color(PPRINT_COLOR_RECURSION)
		return null
	}

	//Print out the object, doing different things depending on the type
	if object.class() == tableClass {
		//This is a table, recurse it
		json.next("$[\n").color(PPRINT_COLOR_TABLE[tableClass])
		global PPRINT_DEPTH = PPRINT_DEPTH + 1
		alreadyPrinted[object] = true
		object.each(fn(k, v) {
			json.next(spacing + spacerPart).color(PPRINT_SPACER_COLOR)
			if (k.class() != stringClass)
				json.next("[")
			printEndpoint(json, k, true, allowHover)
			if (k.class() != stringClass)
				json.next("]")
			json.next(" = ")
			printRecursive(json, v, depthLeft - 1, indent + 1, allowHover, alreadyPrinted)
			json.next("\n")
		})
		global PPRINT_DEPTH = PPRINT_DEPTH - 1
		json.next(spacing).color(PPRINT_SPACER_COLOR).next("]").color(PPRINT_COLOR_TABLE[tableClass])
	} else if object.class() == listClass {
		//This is a list, recurse
		json.next("![\n").color(PPRINT_COLOR_TABLE[listClass])
		global PPRINT_DEPTH = PPRINT_DEPTH + 1
		alreadyPrinted[object] = true
		object.each(fn(elem) {
			json.next(spacing + spacerPart).color(PPRINT_SPACER_COLOR)
			printRecursive(json, elem, depthLeft - 1, indent + 1, allowHover, alreadyPrinted)
			json.next("\n")
		})
		global PPRINT_DEPTH = PPRINT_DEPTH - 1
		json.next(spacing).color(PPRINT_SPACER_COLOR).next("]").color(PPRINT_COLOR_TABLE[listClass])
	} else {
		printEndpoint(json, object, false, allowHover)
	}
}

//Format the object and returns a json text object
global fn pformat(object, maxDepth, allowHover) {
	if maxDepth < 0 maxDepth = 0
	global PPRINT_MAX_DEPTH = maxDepth
	global PPRINT_DEPTH = 0
	json = JsonText("")
	printRecursive(json, object, maxDepth, 0, allowHover, $[])
	json
}

//Prints the formatted json text of the object
global fn pprint(object, maxDepth) {
	print(pformat(object, maxDepth, true))
}
