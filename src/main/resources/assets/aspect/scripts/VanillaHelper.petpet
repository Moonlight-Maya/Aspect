//Run the function now if the user exists, 
//or register it to the init event if they don't
fn runNowOrLater(func) {
	if user func() else events.USER_INIT.add(fn() {
		func()
		events.USER_INIT.del(this)
	})
}

//Find the vanilla model part which matches the given name, if it exists, or else null
fn findPart(name, partsTable) {
	found = null
	//Set found to null, iterate the parts table to find the correct vanilla part
	partsTable.each(fn(partName, part) {
		if found or partName.class() == 0.class() //already found, or it's a number, skip
			return null
		if name.starts(partName)
			found = part
	})
	//return the found part, or null if we found nothing
	found
}

fn setupKeywordsRecursive(modelPart, partsTable) {
	//Only set keywords for groups
	if modelPart.bbType() == "GROUP" {
		//If we find a part, then add it to the transformers list if possible
		if (vanillaPart = findPart(modelPart.name().lower(), partsTable)) {
			//If it's a table, don't set the transformer, instead just recurse
			if (vanillaPart.class() == $[].class()) {
				modelPart.children().each(fn(child) {
					setupKeywordsRecursive(child, vanillaPart)
				})
			} else {
				modelPart.transformers().push(vanillaPart)
				//Recurse on the children with the vanilla part's children
				modelPart.children().each(fn(child) {
					setupKeywordsRecursive(child, vanillaPart.children())
				})
			}
		} else {
			//Recurse on all the children
			modelPart.children().each(fn(child) {
				setupKeywordsRecursive(child, partsTable)
			})
		}
	}
}

//Use this kind of hacky workaround to get something that,
//when calling children(), returns the parts
FeatureContainer = class("FeatureContainer", $[
	__init = fn(feature) {
		this.feature = feature
		this
	},
	children = fn() this.feature.parts()
])

//Run this function and your part names will be scanned for keywords,
//and the vanilla parents will be added accordingly
global fn setupKeywords() {
	//Vanilla model only exists once the user is loaded in,
	//so register this to the event
	runNowOrLater(fn() {

		//Generate a copy of the vanilla parts
		partsTable = vanilla.parts().copy()

		//Set up the feature part names as well
		//This way will insert a table instead of a part object,
		//so we handle that up above
		vanilla.features().each(fn(index, feature) {
			partsTable["feature" + index] = feature.parts()
		})

		//pprint(partsTable, 10)

		//Recursively setup keywords for parts
		setupKeywordsRecursive(models.entity, partsTable)
		setupKeywordsRecursive(models.hud, partsTable)
		models.world.eachV(fn(v) setupKeywordsRecursive(v, partsTable))
	})
}

//Features do not have names given by Minecraft itself, so instead these aliases
//are defined here for easier understanding. Call setupFeatureAliases() to make
//these available.
featuresMap = $[
	player = !["armor", "heldItems", "arrows", "ears", "cape", "headItem", "elytra", "parrot", "riptide", "stingers"],
	armor_stand = !["armor", "heldItems", "elytra", "headItem"],
	mooshroom = !["mushrooms"],
	llama = !["decor"],
	panda = !["heldItem"],
	wandering_trader = !["headItem", "heldItem"],
	spider = !["eyes"],
	warden = !["glow", "spots1", "spots2", "tendrils", "heart"],
	phantom = !["eyes"],
	cat = !["collar"],
	slime = !["overlay"],
	snow_golem = !["pumpkin"],
	creeper = !["charge"],
	wither = !["armor"],
	fox = !["heldItem"],
	shulker = !["head"],
	iron_golem = !["crack", "flower"],
	giant = !["heldItem", "armor"],
	tropical_fish = !["overlay"],
	strider = !["saddle"],
	sheep = !["wool"],
	villager = !["headItem", "clothing", "heldItem"],
	horse = !["marking", "armor"],
	pig = !["saddle"],
	zombie_villager = !["headItem", "elytra", "heldItems", "armor", "clothing"],
	zombie = !["headItem", "elytra", "heldItems", "armor"],
	husk = !["headItem", "elytra", "heldItems", "armor"],
	drowned = !["headItem", "elytra", "heldItems", "armor", "overlay"],
	skeleton = !["headItem", "elytra", "heldItems", "armor"],
	stray = !["headItem", "elytra", "heldItems", "armor", "overlay"],
	wither_skeleton = !["headItem", "elytra", "heldItems", "armor"],
	piglin = !["headItem", "elytra", "heldItems", "armor"],
	wolf = !["collar"],
	dolphin = !["heldItem"],
	vindicator = !["headItem", "heldItem"],
	illusioner = !["headItem", "heldItem"],
	evoker = !["headItem", "heldItem"],
	pillager = !["headItem", "heldItem"],
	enderman = !["eyes", "heldItem"],
	witch = !["heldItem"],
	allay = !["heldItem"],
	vex = !["heldItem"]
]

//Provides some alternate names for the
//feature renderers, instead of using just the
//numbers
global fn setupFeatureAliases() {
	runNowOrLater(fn() {
		typename = {
			t = user.getType()
			t.sub(t.find(":")+1, t.len())
		}
		if (featureNameList = featuresMap[typename]) {
			features = vanilla.features()
			featureNameList.eachI(fn(i, name) {
				features[name] = features[i]
			})
		}
	})
}
